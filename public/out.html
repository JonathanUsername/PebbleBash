<!DOCTYPE html>
<html lang="en">
  <head>
    <title>ORIENTATION</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <style>
      body {
        margin: 0px;
        background-color: #000000;
        overflow: hidden;
      }

      .controls {
        position: fixed;
        left: 0;
        bottom: 0;
        height: 100px;
        width: 200px;
        background: black;
        color: white;
        font-size: 20px
        font-weight: bold;
      }
    </style>
  </head>
  <body>

    <script src="three.min.js"></script>
    <script src="/socket.io/socket.io.js"></script>

    <script>

      var DeviceOrientationControls = function( object ) {

        var scope = this;

        this.object = object;
        this.object.rotation.reorder( "YXZ" );

        this.enabled = true;

        this.deviceOrientation = {};
        this.screenOrientation = 0;

        this.alpha = 0;
        this.alphaOffsetAngle = 0;


        this.onDeviceOrientationChangeEvent = function( event ) {
          // console.log(event)

          scope.deviceOrientation = event;

        };

        // The angles alpha, beta and gamma form a set of intrinsic Tait-Bryan angles of type Z-X'-Y''

        var setObjectQuaternion = function() {

          var zee = new THREE.Vector3( 0, 0, 1 );

          var euler = new THREE.Euler();

          var q1 = new THREE.Quaternion( - Math.sqrt( 0.5 ), 0, 0, Math.sqrt( 0.5 ) ); // - PI/2 around the x-axis

          return function( quaternion, alpha, beta, gamma ) {

            euler.set( beta, alpha, - gamma, 'YXZ' ); // 'ZXY' for the device, but 'YXZ' for us

            quaternion.setFromEuler( euler ); // orient the device

            quaternion.multiply( q1 ); // camera looks out the back of the device, not the top

            // console.log({
            //   zee: zee, 
            //   euler: euler,
            //   q1: q1
            // })

          }

        }();


        this.update = function() {

          if ( scope.enabled === false ) return;

          var alpha = scope.deviceOrientation.alpha ? THREE.Math.degToRad( scope.deviceOrientation.alpha ) + this.alphaOffsetAngle : 0; // Z
          var beta = scope.deviceOrientation.beta ? THREE.Math.degToRad( scope.deviceOrientation.beta ) : 0; // X'
          var gamma = scope.deviceOrientation.gamma ? THREE.Math.degToRad( scope.deviceOrientation.gamma ) : 0; // Y''

          setObjectQuaternion( scope.object.quaternion, alpha, beta, gamma );
          // console.log(scope.object.quaternion, alpha, beta, gamma)
          this.alpha = alpha;

        };

        this.updateAlphaOffsetAngle = function( angle ) {

          this.alphaOffsetAngle = angle;
          this.update();

        };

        scope.enabled = true;

        return this;

      };

      // -------------------------------------------------------------------------------------------

      var socket = io.connect();
      var orientation;

      socket.on('connect', function(sock) {
        console.log('connected');
      })

      socket.on('orientate', function(o) {
        // console.log(o)
        orientation.onDeviceOrientationChangeEvent(o)
      })

      socket.on('joined', function(rm) {
        document.getElementsByTagName('body')[0].innerHTML += '<div class="controls">Go to ' + location.href + 'in?' + rm + ' on your phone.</div>'
      })

      socket.on('start', () => {
        console.log('started')
        startScene()
      })

      function startScene() {
        var camera, scene, renderer;
        var mesh;
        init();
        orientation = DeviceOrientationControls(mesh)
        animate();
        function init() {
          camera = new THREE.PerspectiveCamera( 70, window.innerWidth / window.innerHeight, 1, 1000 );
          camera.position.z = 400;
          scene = new THREE.Scene();
          var texture = new THREE.TextureLoader().load( 'me.jpg' );
          var geometry = new THREE.BoxBufferGeometry( 200, 200, 200 );
          var material = new THREE.MeshBasicMaterial( { map: texture } );
          mesh = new THREE.Mesh( geometry, material );
          scene.add( mesh );
          renderer = new THREE.WebGLRenderer();
          renderer.setPixelRatio( window.devicePixelRatio );
          renderer.setSize( window.innerWidth, window.innerHeight );
          document.body.appendChild( renderer.domElement );
          //
          window.addEventListener( 'resize', onWindowResize, false );
        }
        function onWindowResize() {
          camera.aspect = window.innerWidth / window.innerHeight;
          camera.updateProjectionMatrix();
          renderer.setSize( window.innerWidth, window.innerHeight );
        }
        function animate() {
          requestAnimationFrame( animate );
          orientation.update()
          // mesh.rotation.x += 0.005;
          // mesh.rotation.y += 0.01;
          renderer.render( scene, camera );
        }
      }

      
    </script>

  </body>
</html>